name: create release
'on': push
jobs:
  release-project:
    name: Release different versions of Text file
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: 'python -m pip install --upgrade pip

        pip install zipfile36 openpecha PyYAML

        '
    - name: Create zip file for text and hfml
      run: |
        import os 
        import re
        import yaml
        from zipfile36 import ZipFile
        from os.path import basename
        from pathlib import Path
        from openpecha.serializers import HFMLSerializer

        def get_meta_info(meta_data):
            volumes = meta_data['vol2fn']
            cur_text = {}
            meta_info = {}
            num = 1
            for vol_num, image_group in volumes.items():
                image_group = volumes[vol_num][1:-4]
                cur_text[num] = { 
                    'image_group': image_group,
                    'vol_num': vol_num,
                }
                meta_info.update(cur_text)
                num += 1
                cur_text = {}
            return meta_info

        def change_file_name_pages(pages, pages_path, meta_info):
            _type = "pages"
            for num, vol_num in enumerate(pages,1):
                for info_num, meta in meta_info.items():
                    meta_vol = meta['vol_num']
                    if meta_vol == vol_num:
                        content = pages[f'{vol_num}']
                        lines = re.split(f"(\\\n)", content)
                        pages_content = get_clean_pages(lines, meta_info, vol_num)
                        write_text(pages_content, pages_path, vol_num, _type)
                        break

        def change_file_name_plain(meta_info, opf_path, new_path):
            _type = "plain"
            for file in os.listdir(f"{opf_path}/base"):
                if file.endswith(".txt"):
                    file_path = Path(f"{opf_path}/base/{file}")
                    file_name = file[1:-4]
                    content = Path(f'{file_path}').read_text(encoding='utf-8')
                    for info_num, meta in meta_info.items():
                        vol = meta['vol_num']
                        new_vol = vol[1:]
                        if new_vol == file_name:
                            vol_num = file_name
                            write_text(content, new_path, vol_num, _type)    
                            break

        def create_zip(base_path, name):
            with ZipFile(name, 'w') as zipObj:
                for folderName, subfolders, filenames in os.walk(base_path):
                    for filename in filenames:
                        filePath = os.path.join(folderName, filename)
                        zipObj.write(filePath, basename(filePath))

        def erase_page_index(new_content, meta_info, vol_num):
            new_line = []
            new_page = ""
            lines = re.split(f"(\\\n)", new_content)
            for num, meta in meta_info.items():
                meta_num = meta['vol_num']
                if vol_num == meta_num:
                    image_group = meta['image_group']
                    for num, line in enumerate(lines,1):
                        if re.match(f"\s({image_group}\_\d+)", line):
                            new_line = re.sub(f"\s({image_group}\_\d+)", "", line )
                            if new_line != '':
                                new_page += new_line
                                new_line = []
                        elif re.match(f"(\\\n)", line):
                            new_page += "\n"
                        elif line != '':
                            new_page += line
            return new_page

        def get_clean_pages(lines, meta_info, vol_num):
            new_line = []
            new_content = ""
            for num, line in enumerate(lines,1):
                if  num % 2 != 0:
                    new_line = re.sub(f"(\[((.\d+\w)|(\d+(a|b)\.\d+)|(\.\d+))\])", "", line )
                    new_content += new_line
                    new_line = []
                else:
                    new_content += "\n"
            new_content = erase_page_index(new_content, meta_info, vol_num)
            return new_content

        def write_text(content, new_path, vol_num, _type):
            out_fn = Path(f"{new_path}/{vol_num}_{_type}.txt")
            out_fn.write_text(content, encoding='utf-8')

        if __name__=="__main__":
            pecha_id = Path.cwd().name
            opf_path = Path.cwd().resolve() / f"{pecha_id}.opf"
            meta_content = Path(f'{opf_path}/meta.yml').read_text(encoding='utf-8')
            meta_data = yaml.safe_load(meta_content)
            base_path = Path(f'{opf_path}/base')
            plain_path = Path(f"./output/publication/plains")
            plain_path.mkdir(exist_ok=True, parents=True)
            meta_info = get_meta_info(meta_data)
            change_file_name_plain(meta_info, opf_path, plain_path) 
            create_zip(plain_path, f"{pecha_id}_plain.zip")
            pages_path = Path(f"./output/publication/pages")
            pages_path.mkdir(exist_ok=True, parents=True)
            serializer = HFMLSerializer(opf_path, layers=["Pagination"])
            serializer.apply_layers()
            results = serializer.get_result()
            pages = results
            change_file_name_pages(pages, pages_path, meta_info)
            create_zip(pages_path, f"{pecha_id}_pages.zip")
      shell: python
      
    - name: Create Github Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ github.run_number }}
        release_name: Release ${{ github.run_number }}
        draft: false
        prerelease: false
        
    - name: upload base assets
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{  secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./${{ github.event.repository.name }}_plain.zip
        asset_name: ka_gyur_puk_drak_dri_ma_plain_4c0ea8.zip
        asset_content_type: text/zip
        
    - name: upload hfml assets
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{  secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./${{ github.event.repository.name }}_pages.zip
        asset_name: ka_gyur_puk_drak_dri_ma_pages_4c0ea8.zip
        asset_content_type: text/zip
