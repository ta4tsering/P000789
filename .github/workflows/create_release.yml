name: create release
'on':
  push:
    paths-ignore: '**/README.md'
jobs:
  release-project:
    name: Release different versions of Text file
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: 'python -m pip install --upgrade pip

        pip install zipfile36 openpecha PyYAML rdflib requests

        '
    - name: Create zip file for plain and pages
      run: "import os \nimport re\nimport yaml\nfrom zipfile36 import ZipFile\nfrom\
        \ os.path import basename\nfrom pathlib import Path\nfrom openpecha.serializers\
        \ import HFMLSerializer\n\ndef get_meta_info(meta_data):\n    volumes = meta_data['vol2fn']\n\
        \    cur_text = {}\n    meta_info = {}\n    num = 1\n    for vol_num, image_group\
        \ in volumes.items():\n        image_group = volumes[vol_num][1:-4]\n    \
        \    cur_text[num] = { \n            'image_group': image_group,\n       \
        \     'vol_num': vol_num,\n        }\n        meta_info.update(cur_text)\n\
        \        num += 1\n        cur_text = {}\n    return meta_info\n\ndef change_file_name_pages(pages,\
        \ pages_path, meta_info):\n    _type = \"pages\"\n    for num, vol_num in\
        \ enumerate(pages,1):\n        for info_num, meta in meta_info.items():\n\
        \            meta_vol = meta['vol_num']\n            if meta_vol == vol_num:\n\
        \                content = pages[f'{vol_num}']\n                lines = re.split(f\"\
        (\\\\\\n)\", content)\n                pages_content = get_clean_pages(lines,\
        \ meta_info, vol_num)\n                write_text(pages_content, pages_path,\
        \ vol_num, _type)\n                break\n            \ndef change_file_name_plain(meta_info,\
        \ opf_path, new_path):\n    _type = \"plain\"\n    for file in os.listdir(f\"\
        {opf_path}/base\"):\n        if file.endswith(\".txt\"):\n            file_path\
        \ = Path(f\"{opf_path}/base/{file}\")\n            file_name = file[1:-4]\n\
        \            content = Path(f'{file_path}').read_text(encoding='utf-8')\n\
        \            for info_num, meta in meta_info.items():\n                vol\
        \ = meta['vol_num']\n                new_vol = vol[1:]\n                if\
        \ new_vol == file_name:\n                    vol_num = file_name\n       \
        \             write_text(content, new_path, vol_num, _type)    \n        \
        \            break\n\ndef create_zip(base_path, name):\n    with ZipFile(name,\
        \ 'w') as zipObj:\n        for folderName, subfolders, filenames in os.walk(base_path):\n\
        \            for filename in filenames:\n                filePath = os.path.join(folderName,\
        \ filename)\n                zipObj.write(filePath, basename(filePath))\n\n\
        def erase_page_index(new_content, meta_info, vol_num):\n    new_line = []\n\
        \    new_page = \"\"\n    lines = re.split(f\"(\\\\\\n)\", new_content)\n\
        \    for num, meta in meta_info.items():\n        meta_num = meta['vol_num']\n\
        \        if vol_num == meta_num:\n            image_group = meta['image_group']\n\
        \            for num, line in enumerate(lines,1):\n                if re.match(f\"\
        \\s({image_group}\\_)\", line):\n                    new_line = re.sub(f\"\
        \\s({image_group}\\_)\", \"\", line )\n                    if new_line !=\
        \ '':\n                        img_num = int(new_line)\n                 \
        \       new_page += f\" i-{img_num}\"\n                        new_line =\
        \ []\n                elif re.match(f\"(\\\\\\n)\", line):\n             \
        \       new_page += \"\\n\"\n                elif line != '':\n          \
        \          new_page += line\n    return new_page\n\ndef get_clean_pages(lines,\
        \ meta_info, vol_num):\n    new_line = []\n    new_content = \"\"\n    for\
        \ num, line in enumerate(lines,1):\n        if  num % 2 != 0:\n          \
        \  new_line = re.sub(f\"(\\[((.\\d+\\w)|(\\d+(a|b)\\.\\d+)|(\\.\\d+))\\])\"\
        , \"\", line )\n            new_content += new_line\n            new_line\
        \ = []\n        else:\n            new_content += \"\\n\"\n    new_content\
        \ = erase_page_index(new_content, meta_info, vol_num)\n    return new_content\n\
        \ndef write_text(content, new_path, vol_num, _type):\n    out_fn = Path(f\"\
        {new_path}/{vol_num}_{_type}.txt\")\n    out_fn.write_text(content, encoding='utf-8')\n\
        \n\nif __name__==\"__main__\":\n    pecha_id = Path.cwd().name\n    opf_path\
        \ = Path.cwd().resolve() / f\"{pecha_id}.opf\"\n    meta_content = Path(f'./{pecha_id}/{pecha_id}.opf/meta.yml').read_text(encoding='utf-8')\n\
        \    meta_data = yaml.safe_load(meta_content)\n    base_path = Path(f'{opf_path}/base')\n\
        \    plain_path = Path(f\"./output/publication/plains\")\n    plain_path.mkdir(exist_ok=True,\
        \ parents=True)\n    meta_info = get_meta_info(meta_data)\n    change_file_name_plain(meta_info,\
        \ opf_path, plain_path) \n    create_zip(plain_path, f\"{pecha_id}_plain.zip\"\
        )\n    pages_path = Path(f\"./output/publication/pages\")\n    pages_path.mkdir(exist_ok=True,\
        \ parents=True)\n    serializer = HFMLSerializer(opf_path, layers=[\"Pagination\"\
        ])\n    serializer.apply_layers()\n    pages = serializer.get_result()\n \
        \   change_file_name_pages(pages, pages_path, meta_info)\n    create_zip(pages_path,\
        \ f\"{pecha_id}_pages.zip\")\n"
      shell: python
    - name: Create Github Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ github.run_number }}
        release_name: Release ${{ github.run_number }}
        draft: false
        prerelease: false
    - name: upload plain assets
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{  secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./${{ github.event.repository.name }}_plain.zip
        asset_name: kagyur_puk_drak_drima_plain_4c0ea8.zip
        asset_content_type: text/zip
    - name: upload pages assets
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{  secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./${{ github.event.repository.name }}_pages.zip
        asset_name: kagyur_puk_drak_drima_pages_4c0ea8.zip
        asset_content_type: text/zip
